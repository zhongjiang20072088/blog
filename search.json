[{"title":"运行一个arm32程序","url":"/blog/2025/07/15/arm-start/","content":"运行一个arm32程序由于本地电脑是windows系统，是x86_64架构，不能够直接运行arm32程序，所以需要在运行程序前需要一个能运行arm程序的环境，有两种方式1. 通过模拟器模拟arm32的运行环境；2. 用真机，例如raspberry pi；由于我没有真机，树莓派下单还没有到手，所以还是采用模拟器的方式，通过qemu来模拟。\n环境搭建\n宿主平台windows\nqemu安装包\n树莓派镜像\nkernel-qemu\n\n启动系统完整命令如下:\nqemu-system-arm -M versatilepb -cpu arm1176 -m 256 -drive &quot;file=E:\\workspace\\qemu_imgs\\2020-02-13-raspbian-buster.img,if=none,index=0,media=disk,format=raw,id=disk0&quot; -device &quot;virtio-blk-pci,drive=disk0,disable-modern=on,disable-legacy=off&quot; -net &quot;user,hostfwd=tcp::5022-:22&quot; -dtb versatile-pb-buster-5.4.51.dtb -kernel kernel-qemu-5.4.51-buster -append &quot;root=/dev/vda2 panic=1&quot; -no-reboot -net nic\n\nqemu 常用的命令参数：\n基本参数\n\n-M &lt;machine&gt;: 指定要模拟的机器类型。例如，-M versatilepb用于模拟ARM的VersatilePB开发板。\n-cpu &lt;cpu&gt;: 指定要模拟的CPU类型。例如，-cpu cortex-a8用于模拟ARM Cortex-A8处理器。\n-m &lt;size&gt;: 指定虚拟机的内存大小，以MB为单位。例如，-m 256分配256MB内存给虚拟机。\n\n启动参数\n\n-kernel &lt;file&gt;: 指定内核镜像文件，用于启动虚拟机。例如，-kernel zImage。\n-initrd &lt;file&gt;: 指定初始内存盘（initrd）文件，用于启动时加载根文件系统。\n-append &lt;cmdline&gt;: 向内核传递命令行参数。例如，-append &quot;console=ttyAMA0 root=/dev/ram&quot;。\n\n图形和现实参数\n\n-nographic: 禁用图形输出，仅使用命令行界面。这在没有图形界面的环境中很有用。\n-display &lt;type&gt;: 指定显示类型。例如，-display gtk使用GTK显示图形界面。\n\n磁盘和文件系统参数\n\n-hda &lt;file&gt;: 指定虚拟机的硬盘映像文件。例如，-hda disk.img。\n-drive &lt;options&gt;: 用于更高级的磁盘配置。例如，-drive file=disk.img,format=raw,if=virtio。\n\n网络参数\n\n-net &lt;options&gt;: 配置虚拟机的网络。例如，-net nic创建一个网络接口。\n-net user,&lt;options&gt;: 使用用户模式网络堆栈，提供简单的网络连接。例如，-net user,hostfwd=tcp::2222-:22将主机的2222端口转发到虚拟机的22端口。\n\n其他参数\n\n-smp &lt;cpus&gt;: 指定虚拟机的CPU数量。例如，-smp 4分配4个虚拟CPU。\n-serial &lt;device&gt;: 配置串行端口。例如，-serial stdio将串行输出重定向到标准输入输出。\n-enable-kvm: 启用KVM加速（仅在支持KVM的系统上有效），以提高虚拟机性能。\n-snapshot: 启动虚拟机时创建快照，所有写操作不会影响磁盘映像。\n\n\n系统启动进入到桌面，这个桌面里可以看到terminal图标，之后就可以打开一个terminal，使用linux系统自带的vi编辑器写程序，然后用系统的as和ld编译链接工具生成可以执行程序，如果写的程序执行有问题可以用gdb进行调试。\n第一个arm程序.section .datamsg:    .asciz &quot;Hello, ARM World!\\n&quot;.section .text.global _start_start:    ldr r0, =msg       // Load address of msg into r0    mov r1, #1         // File descriptor (stdout)    ldr r2, =18        // Length of the message    mov r7, #4         // sys_write syscall number    svc 0              // Call the kernel    mov r0, #0         // Exit code 0    mov r7, #1         // sys_exit syscall number    svc 0              // Call the kernel \n\n上面的程序通过标准输出，打印”Hello, ARM World!”，保存的文件名为hello.s，然后进行汇编和链接：\n\nas -o hello.o hello.s\nld -o hello hello.o\n\n最后执行命令./hello，输出”Hello, ARM World!”，至此环境搭建和运行程序完成，后续可以通过该环境开始后续的学习计划。\n","tags":["arm","arm32","assembly"]},{"title":"arm学习开篇","url":"/blog/2025/07/10/arm/","content":"写这篇文章的动机​\t最近成都公司解散，在这个公司工作了差不多三年多，主要做目前比较热火的XR眼睛，也开始接触到一些嵌入式相关的知识，之前主要的工作是android应用以及android系统框架，所以对于我来说是一个全新的领域，我也是抱着极大的热情与投入参入到新的工作环境，但是接触工作后发现自己的工作还是偏上层，基于嵌入式操作系统做应用开发，翻译、提词器等等，这和之前的预想有很大偏差，嵌入式应该是和寄存器、中断、RTOS这些打交道吗，:sleepy:  现在回想一下做的事情对于我个人的技能提升有限，知识面也没有什么拓展，在当前的工作环境下要找到一份新的工作对于我来说感觉好难，年纪一看也过了35岁的坎，写到这里心里难免也沉重了不少，sigh；人生就是这样，你也没有办法知道做的选择到底是对还是错，必须为自己做的事情买单。不过回头过来想想，目前的困局也不光是工作内容，也与自己的懈怠有关，工作之余难道不能自己去学习自己感兴趣的技术？总结复盘工作的知识，哪怕是再简单也会有一些亮点吧；这几天思来想去，现在是时候做出一些改变，把未来要做的事情规划一下：\n\n学习新的知识（主要是嵌入式方向）\n梳理之前工作中的知识\n刷一刷算法题\n记录生活中的点滴\n看书\n\n人生处处是起点，无论何时开始都不算晚，是时候告别过去，开启新的篇章。\n什么是armarm（Advanced RISC Machines）是英国arm公司设计的32位精简指令集(RISC)处理器架构，对比就是intel x86使用的复杂指令集(CISC)处理架构，区别于intel，arm的指令只会操作寄存器通过Load&#x2F;Store指令访问内存(好像push&#x2F;pop也可以)，就是说如果要将内存中的整数加1，需要通过Load从内存中加载整数，然后通过指令(add)将寄存器中的值加1，然后通过Store将其存到内存中。\narm采用RISC架构有优点也有缺点。优点是它的指令执行更快，是因为每条指令需要时钟周期更短，其次每条指令都是32位的，用RISC架构编写的程序有更大的代码密度，从而有更小的内存占用空间；着重软件编写的效率也带来了不好的一面，就是指令很少。\narm以低功耗、高性能和可定制化为核心特点，广泛应用于嵌入式系统设计、工业控制、消费电子、通信系统等领域，它也很多个版本：\n\n\n\nARM 系列\nARM架构\n\n\n\nARM7\nARM V4\n\n\nARM9\nARM v5\n\n\nARM11\nARM v6\n\n\nCortex-A\nARM v7-A\n\n\nCortex-R\nARM v7-R\n\n\nCortex-M\nARM v7-M\n\n\n其中Cortex系列是目前使用的主流\n\nCortex-A系列面向高性能计算设备，支持linux&#x2F;android等复杂操作系统。采用多级流水线、超标量执行等技术，主要用于只能手机、个人电脑、服务器等需要多处理任务和复杂计算的场景\n\nCortex-R系列专为实时控制系统设计，强调低延迟和可预测性。通常用于工业控制、医疗设备等需要高可靠性和实时响应的领域，在上面可以跑RTOS\n\nCortex-M系列面向低功耗嵌入式系统，支持中断处理和单周期执行。适用于微控制器、物联网等对功耗敏感场景。\n\n\n学习计划了解了上面的背景之后，有打算按以下步骤来学习arm相关的知识\n\n用arm写一个程序，在模拟器或者一个真机上\narm的数据类型以及寄存器\narm的指令集\n内存指令：Load、Store\n指令的条件执行以及分支控制(B、BL、BLX)\n栈以及函数\n\n","tags":["arm"]},{"title":"Hello World","url":"/blog/2025/07/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]